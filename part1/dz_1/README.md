# Условие задания
1.	Написать класс, который  умеет построчно читать из файла и писать в файл, то есть имеет методы `ReadString()` и `WriteString()`.
2.	Добавить шифрование/дешифрование строк через адаптер. В качестве алгоритма шифрования подойдет XOR с ключом.
3.	Ключ шифрования и пути к файлам – входные параметры.

Можно пользоваться любыми средствами стандартной библиотеки и/или boost.

## Критерии
1.	Управление памятью осуществлять через умные указатели. Для прочих ресурсов можно использовать самописные guards или существующие решения из Stl/boost.
2.	Если нужны контейнеры, использовать контейнеры из стандартной библиотеки (vector/map/list etc.) или boost.
3.	Обработку ошибок осуществлять через исключения с соблюдением строгой гарантии и с учетом best practices. 
4.	Продумать архитектуру приложения: интерфейсы, ответственность отдельных классов и т.д. Поскольку обсуждались темы ООП и паттернов, архитектура является важной частью задания. Важно продемонстрируйте понимание принципа работы выбранного паттерна.
5.	Разнести классы по отдельным файлам, это тоже часть декомпозиции.

## Формат сдачи
Необходимо загрузить целиком папку проекта за исключением exe и pdb файлов

## Обзор решения
Проект содержит следующие файлы:  
**`FileWriter.h`**  - Содержит в себе описание класса, реализующего построчное чтение и запись из файла в файл  
**`FileWriter.cpp`** - Содержит реализацию класса построчного копирования из файла в файл  
**`Encryption.h`** - Содержит в себе описание класса-адаптера для `FileWriter` с методом шифрования/дешифрования считанной из файла строки   
**`Encryption.cpp`** - Содержит в себе реализацию класса-адаптера для `FileWriter`
**`main.cpp`** - Содержит в себе набор тестов для обоих классов  

Реализация предполагает отдельные методы для чтения строки текста из файла 
~~~C++
const std::string ReadString();
~~~
и для записи строки в другой файл 
~~~C++
void WriteString(const std::string bufer);
~~~
Метод `ReadString` считывает строку, сохраняет её в `string` буфер и передает этот буфер во `WriteString`.   
Для того, чтобы поддерживать актуальные точки чтения из файла и записи в файл, в классе объявлены поля
~~~C++
std::ifstream sourceFilePointer;
std::ofstream destinationFilePointer;
~~~
а так же поля, содержащие пути к обоим файлам:
~~~C++
std::string sourceFileName;
std::string destinationFileName;
~~~
которые заполняются при вызове конструктора класса:
~~~C++
explicit FileWriter(const std::string _sourceFileName, const std::string _destinationFileName);
~~~
Помимо этого, в классе реализован метод, циклически вызывающий `ReadString` и `WriteString` до полного копирования файла:
~~~C++
void CopyTextFromFile();
~~~
На случай возможных исключений при открытии файлов и работе с ними, реализована функция:
~~~C++
void CloseFiles();
~~~
правильно закрывающая открытые потоки. Этот же метод вызывается при срабатывании деструктора класса:
~~~C++
~FileWriter();
~~~

Файл `Encryption.h` и соответствующий ему `FileWriter.cpp` содержит в себе абстрактный класс `IEncrypt` с чисто виртуальным методом 
~~~C++
virtual void Encrypt(const int key) = 0;
~~~
и виртуальным деструктором 
~~~C++
virtual ~IEncrypt() {}
~~~
Данный класс является шаблоном для различных видов шифрования, которые могут быть реализованы для исходного `FileWriter`.

В этом же файле реализован класс 
~~~C++
class XorEncriptionAdapter : public IEncrypt
~~~
реализующий шифрование/дешифрование считанной из файла строки при помощи XOR с ключом.  
Файл содержит конструктор, принимающий указатель на экземпляр класса `FileWriter`
~~~C++
explicit XorEncriptionAdapter(FileWriter* p);
~~~
Непосредственно метод, производящий шифрование/дешифрование считанной строки:
~~~C++
void Encrypt(const int _key);
~~~
И деструктор
~~~C++
~XorEncriptionAdapter() {};
~~~
который к слову не выполняет каких-либо операций, поскольку контроль за ресурсом обеспечивает сам `FileWriter`.

Файл `main.cpp` содержит набор тестов, проверяющий работу класса `FileWriter` без шифрования, а так же с шифрование и дешифрованием строки при помощи заданного ключа.

## Полученная оценка:
98 из 100  
[Ошибки в реализации и исправленная версия программы](dz_1_new/)
