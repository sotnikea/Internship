# Язык C++. Обзор вопросов задаваемых на собеседовании.
## Оглавление
1. [ООП](#r1)
2. [Работа с исключениями](#r2)
3. [Работа с ресурсами и памятью](#r3)
4. [Тонкости  С+](#r4)
5. [Паттерны проектирования](#r5)
6. [Вопросы/ответы](#r6)
______


## <a name="r1">ООП</a>

**ООП** - Это способ управления сложностью. Используя ООП можно организовать сложную логику в более мелкие и простые структуры.

**Связность** – это зависимость, при которой внесение изменений в один модуль отражается на другом модуле. Нужно стремиться к уменьшению связности.

**Класс** - Объединение данных (полей)  и работающего с ними кода (методов). Класс нужно проектировать, используя «принцип единственной обязанности» один класс – одна цель

**Инкапсуляция** — механизм языка программирования, который агрегирует данные в  сущности и  ограничивает доступ к составляющим объект компонентам. Реализуется с помощью классов и модификаторов доступа (private, public, protected).

**Наследование** — механизм языка, позволяющий написать новый класс на основе уже существующего (родительского, базового) класса.  

**Класс–потомок** может добавить собственные методы и свойства и пользоваться родительскими методами и свойствами. Позволяет строить иерархии классов. Базовый класс может быть абстрактным.  

**Абстрактный класс (интерфейс)**  – базовый класс который не предполагает создания экземпляров и содержит в себе минимум 1 чисто виртуальную функцию.  
Разница между наследованием и включением (когда объект одного класса является полем другого класса) – наследование реализует отношение «является»: легковой автомобиль  является автомобилем, а включение реализует отношение  «имеет»: автомобиль имеет двигатель.
Полиморфизм - возможность объектов с одинаковой спецификацией иметь различную реализацию. Кратко смысл полиморфизма можно выразить фразой: «Один интерфейс, множество реализаций».
Полиморфизм бывает динамический и статический.  

**Динамический полиморфизм** реализуется с помощью наследования классов и виртуальных функций. Класс-потомок наследует сигнатуры методов класса-родителя, а реализация, в результате переопределения метода, этих методов может быть другой, соответствующей специфике класса-потомка. Другие функции могут работать с объектом как с экземпляром класса-родителя, но если при этом объект на самом деле является экземпляром класса-потомка, то во время исполнения будет вызван метод, переопределенный в классе-потомке. Это называется поздним связыванием.  

**Статический полиморфизм** реализуется с помощью шаблонов и перегрузки функций.
Шаблоны — средство языка C++, предназначенное для кодирования обобщённых алгоритмов, без привязки к некоторым параметрам (например, типам данных, размерам буферов, значениям по умолчанию). В C++ возможно создание шаблонов функций и классов.

~~~C++
Пример шаблона:
template< typename T > 
void sort( T array[], int size );

Вызов:
sort<int>( i, 5 );

Шаблон для класса:
template< class T >
class List
{
  /* ... */
public:
  void Add( const T& Element );
  bool Find( const T& Element );
  /* ... */
};

Экземпляры шаблонных функций создаются во время компиляции – по одному на каждый вызов с определенным типом.
~~~

## <a name="r2">Работа с исключениями</a>  

В С++ при возникновении исключения, происходит раскрутка стека вызовов – экстренный выход из функций вверх по стеку  до первого обработчика исключений подходящего типа, и управление передаётся обработчику. Исключения используются как средство обработки ошибок.   
Второй подход – статусы. Исключения позволяют избежать большого количества проверок статусов при возникновении ошибки во время большой вложенности вызовов процедур.  

**Best practices при работе с исключениями:**  
>1. Бросать исключения из деструкторов запрещено – это может привести к выходу из программы, если  в момент разрушения обьекта уже было активным другое исключение.   
>2. Золотое правило работы с исключениями – бросать по значению, ловить по константной ссылке.
~~~C++
throw std::runtime_error(“Test”);  - бросаем по значению
catch (const std::exception& ex) {
		std::cout << ex.what() << std::endl;
	}  - ловим по константной ссылке.
~~~

3. Нельзя бросать исключения за границы модуля, используйте `catch(…)`, чтобы ни одно исключение не вылетело за границу модуля. В то же время не используйте `catch(…)` для обычной обработки исключений, поскольку это может нарушить обработку других исключений.  

Свои исключения лучше всего наследовать от стандартных `std::exception` или `std::runtime_error`.  

**Гарантии безопасности исключений**  
*Базовая гарантия* - в случае возникновения исключений не должно быть никаких утечек ресурсов.  
*Строгая гарантия* - если при выполнении операции возникает исключение, то это не должно оказать какого-либо влияния на состояние приложения. Строгая гарантия исключений обеспечивает транзакционность операций, когда мы получаем либо все, либо ничего.  
*Гарантия отсутствия исключений* - ни при каких обстоятельствах функция не будет генерировать исключения.  

В C++11 появились новые средства для работы с исключениями: `std::exception_ptr`, `std::current_exception`, `std::rethrow_exception`,  `std::make_exception_ptr`


## <a name="r3">Работа с ресурсами и памятью</a>  
**Принцип RAII** – resource acquisition is initialization. Реализация принципа заключается в том, что ресурс, который может утечь (память в куче, открытые дескрипторы ит.д.) отдается некоторому объекту (guard), который будет ресурсом «владеть». В самом простом виде это выглядит так:
~~~C++
class CGuard
{
private: int* m_i;
public: 
        CGuard(int* i) : m_i(i) {}
        
        ~CGuard() 
        { 
            delete m_i; 
        }
};
~~~
Guard автоматически освобождает ресурс при своем разрушении. 
>**Умный указатель** — класс (обычно шаблонный), имитирующий интерфейс обычного указателя и добавляющий некую новую функциональность, например проверку границ при доступе или очистку памяти.
~~~C++
Часто используемые типы:
std::auto_ptr<>
std::unique_ptr<>
std::shared_ptr<>
std::weak_ptr<>
boost::intrusive_ptr<>
boost::scoped_ptr<>
boost::shared_array<>
boost::ptr_vector<>
~~~

## <a name="r4">Тонкости  С++</a>  
Версия стандарта: читая документацию к различным функциям и классам c++ нельзя забывать под какой стандарт идет разработка, в зависимости от стандарта возможно различное поведение или даже наличие/отсутствие соотвествующих функций.

**Битовые операции** – некоторые операции над группами битов. Часто используются для проверок битовых масок или для умножения/деления на степени двойки
~~~C++
    unsigned char option_viewed = 0x01;
    unsigned char option_edited = 0x02;
    unsigned char option_favorited = 0x04;
    unsigned char option_shared = 0x08;
    unsigned char option_deleted = 0x80;
    unsigned char myArticleFlags;
    myArticleFlags |= option_viewed; //mark as read
    bool deleted = myArticleFlags & option_deleted; //check if deleted

Ключевые слова 
    • mutable – отменить константность для определенного поля
    • volatile – компиллятор не будет оптимизировать эту переменную
    • auto - используется вместо указания точного типа при инициализации переменной
    • decltype – decltype(var) – возвращает тип переменной var
    • extern – импорт переменных из других файлов
    • inline – рекомендация компиллятору заоптимизировать функцию
    • explicit – предотвращает неявное преобразование типов при инициализации
    • const_cast, static_cast, dynamic_cast, reinterpret_cast – преобразования типов
    • override – метод переопределен, final – метод нельзя переопределять, default – дефолтный    конструктор,  delete - запретить использовать конструкторы в классе (автоматическое приведение типов)
    • nullptr – нулевой указатель
~~~

**Множественное наследование**  
Множественное наследование позволяет классу перенимать функциональность у множества других классов, как например, класс StudentMusician может наследовать от класса Person, класса Musician и класса Worker, что сокращенно можно написать: class StudentMusician : Person, Musician, Worker. 

**Виртуальное наследование** - в C++ — один из вариантов наследования, который нужен для решения некоторых проблем, порождаемых наличием возможности множественного наследования (особенно «ромбовидного наследования»), путем разрешения неоднозначности того, методы которого из суперклассов (непосредственных классов-предков) необходимо использовать. Оно применяется в тех случаях, когда множественное наследование вместо предполагаемой полной композиции свойств классов-предков приводит к ограничению доступных наследуемых свойств вследствие неоднозначности. Базовый класс, наследуемый множественно, определяется виртуальным с помощью ключевого слова `virtual`.  

**Порядок инициализации** 
Переменные-члены класса инициализируются в порядке объявления в классе, а не в порядке, описанном в списке инициализации. То же с базовыми классами. Сначала вызываются конструкторы виртуальных базовых классов, потом невиртуальных, потом переменных-членов, потом выполняется тело конструктора.  
Десрукторы вызываются в обратном порядке.

## <a name="r5">Паттерны проектирования</a>	  
**Паттерн проектирования** - повторимая архитектурная конструкция, представляющая собой решение проблемы проектирования в рамках некоторого часто возникающего контекста.   
Порождающие описывают создание (`instantiate`) объекта или группы связанных объектов.    
Абстрактная Фабрика (Abstract Factory), Фабричный метод (Factory method)
Структурные посвящены компоновке объектов (object composition). То есть тому, как сущности могут друг друга использовать. Адаптер (Adapter), Мост (Bridge), Декоратор (Decorator)
Поведенческие  связаны с присвоением обязанностей (responsibilities) объектам. От структурных шаблонов они отличаются тем, что не просто описывают структуру, но и очерчивают шаблоны передачи данных, обеспечения взаимодействия.Наблюдатель (Observer), Посетитель (Visitor), Команда (Command).

## <a name="r6">Вопросы/ответы</a>

Вопрос по условию задания с адаптером: 

>"Напишите класс, который  умеет построчно читать из файла и писать в
файл, то есть имеет методы ReadString() и WriteString()"   
Правильно ли я понимаю, что требуется за раз считывать и записывать именно ОДНУ строку? 
Т.е. считывать в ReadString() сразу весь текст, к примеру, в вектор строк, который в последствии и передавать во WriteString() не стоит?


Ответ:
>Изначально условия именно такие, хоть и слегка искусственные. С другой стороны если хотите реализовать описанный Вами вариант, пожалуйста.  
Только там возможны дополнительные трудности, в частности с большими файлами. Но если хотите - welcome.
