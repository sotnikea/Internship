# Ошибки в реализации

Не обнаруженные ошибки в исходной реализации
- в конструкторе по-умолчанию не используется список инициализации
- возможна утечка памяти в конструкторе по-умолчанию
- оператор копирующего присваивания, реализованный компилятором, будет работать некорректно
- не соблюдается строгая гарантия безопасности исключений в методах https://habr.com/ru/post/126374/
- в copy_names возможна утечка памяти
- copy_names реализована некорректно т.к. часть унаследовання от вектора не копируется
- не используются умные указатели

Ошибки в приложенной реализации:

1. Не нужно использовать голые указатели. Попробуйте использовать стандартный `shared_ptr` и на основе него уже реализовать идиому copy on write

2. Такие методы как `empy`, `size` должны быть константными

3. Оператор присваивания будет работать некорректно

4. Не соблюдается строгая гарантия безопасности исключений

5. Все неконстнатные методы должны создавать копию

6. Прокси класс не нужен,
можно сразу делать копию в неконстантных методах. Знание прокси класса полезно, но он используется на практике не так часто для оптимизации индексирования


# Обзор исправлений

>Не нужно использовать голые указатели. Попробуйте использовать стандартный `shared_ptr` и на основе него уже реализовать идиому copy on write

Проект скорректирован на использование shared_ptr. Использованные в векторе данные объединены в пару. Во все методы программы внесены коррекции и изменена логика с учетом новой структуры данных.

~~~C++
using vector_data = std::vector<std::pair<T, std::string>>;	//save pair of T data and string name

private:	
	std::shared_ptr<vector_data> m_data{};
~~~
>Такие методы как `empy`, `size` должны быть константными

Действительно ошибка имела место. Внесены исправления в следующие методы:

~~~C++
bool empty() const;
size_t size() const;
size_t capacity() const;	
~~~
>Оператор присваивания будет работать некорректно

Данный оператор запрещен в проекте вместе с оператором перемещения
~~~C++
MyVector& operator =(const MyVector& other) = delete;
MyVector& operator =(MyVector&& other) = delete;
~~~
>Не соблюдается строгая гарантия безопасности исключений

Ввиду жесткого дедлайна провести глубокий анализ не удалось. Установлены гарантии неисключения для ряда методов
~~~C++
void push_back(const T& obj, const std::string& name) noexcept;
typename std::vector<std::pair<T, std::string>>::iterator begin() noexcept;
typename std::vector<std::pair<T, std::string>>::iterator end() noexcept;
~~~
>Все неконстнатные методы должны создавать копию

Вероятно ошибка перекликается с ранее указанной проблемой о необходимости обозначения константности всех методов, не меняющих внутреннее состояние данных.  
Анализ программы позволяет считать, что копирование данных (вызов метода `copy_datas`) уже реализовано везде, где это было необходимо. Ввиду этого константность добавлена так же следующему методу
~~~C++
std::pair<const T&, const std::string&> at(size_t index) const;	
~~~
> Прокси класс не нужен,
можно сразу делать копию в неконстантных методах. Знание прокси класса полезно, но он используется на практике не так часто для оптимизации индексирования

Прокси класс исключен из решения. Но при подобной реализации константная перегрузка операторов [] (обязательно необходимая по условию задания) никогда не запускается. Для неконстантных перегрузок [] ввиду этого добавлено копирование, т.к. с помощью них теперь всегда можно менять данные.
~~~C++
const std::pair<const T&, const std::string&> operator[](size_t index) const;	//const overload [size_t]	
	std::pair<T, std::string>& operator[](size_t index);							//overload [size_t]
	const T& operator[](const std::string& name) const;								//const overload [string]		
	T& operator[](const std::string& name);											//overload [string]
~~~

# Оценка результата исправлений  
80 из 100
