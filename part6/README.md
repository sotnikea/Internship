# Qt Framework. Basic concepts
## Оглавление
1. [Часто используемые сущности Qt](#r1)
2. [GUI виджеты](#r2)
3. [Модели и представления](#r3)
4. [Многопоточность](#r4)
5. [События](#r5)
6. [Сигналы и слоты](#r6)
7. [Литература](#r7)
____________________
## <a name="r1">Часто используемые сущности Qt</a>
### [QString](https://doc.qt.io/qt-5/qstring.html)

**Класс строки.** Хранит строку в Юникоде, по-умолчанию кодирует выходную строку в Latin1, но существуют методы для конвертации строки в другие кодировки:
~~~C++
std::string QString::toStdString() const
QString QString::fromStdString(const std::string& str) 
~~~

Включает методы часто предпринимаемых проверок и манипуляций со строками:
~~~C++
bool QString::startsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
bool QString::endsWith(const QStringRef &s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
~~~

Проверяют, начинается или заканчивается ли строка переданной строкой.
~~~C++
QString QString::number(T n, int base = 10)
double QString::toDouble(bool *ok = Q_NULLPTR) const
int QString::toInt(bool *ok = Q_NULLPTR, int base = 10) const
~~~
### [QDateTime](https://doc.qt.io/qt-5/qdatetime.html#QDateTime)
Класс для представления **даты/времени**. Имеет множество полезных функций:
- `fromString(const QString &string, Qt::DateFormat format)` – чтение строки и формирования из неё времени;
- `QString toString(const QString &format) const` – создание строки с датой/временем;
- `uint QDateTime::toTime_t() const` – превращение даты в `Unix timestamp`;
- `QDateTime QDateTime::toUTC() const` – превращение даты в дату в UTC-формате.  

Возвращенная строка имеет внешнее представление в локальном времени с поправкой на временную зону;

### Контейнеры [QVector](https://doc.qt.io/qt-5/qvector.html#QVector), [QList](https://doc.qt.io/qt-5/qlist.html#QList), [QMap](https://doc.qt.io/qt-5/qmap.html#QMap), QMultiMap

Контейнеры `Qt` – функциональные аналоги контейнеров `STL`, но с дополнительными возможностями и оптимизированные для использования с типами `Qt`. Все они НЕ являются наследниками классов `STL`, но имеют схожий интерфейс и ту же архитектуру хранения данных (непрерывный массив, связный список,  дерево). Их итераторы совместимы с алгоритмами `STL`, а операции над контейнерами посредством итераторов имеют те же самые ограничения и последствия, что и для контейнеров `STL`: например после вставки элемента в `QVector` его итераторы становятся недействительными.

## <a name="r2">GUI Виджеты</a>

Каждый элемент управления (кнопка, скролл-бар, диалог) называется **виджетом** и каждый из классов элементов управления (`QPushButton, QScrollBar, QDialog`) наследуется от класса `QWidget`. `QWidget`, в свою очередь, наследуется от QObject и поддерживает `parent-child` отношения: `QWidget` принимает указатель на другой `QWidget` в своем конструкторе:
~~~C++
QWidget::QWidget(QWidget * parent = 0, Qt::WindowFlags f = 0)  
~~~

Родительский виджет, который будет передан в конструктор дочернего, удалит дочерний виджет в своем деструкторе.  

Такой подход к построению `GUI` позволяет создавать иерархию виджетов, в которой удаление, допустим, диалога, приведет к удалению всех его дочерних элементов. Поэтому в коде `Qt` манипулирование голыми указателями на большие объекты не выглядит опасным.

Существует множество встроенных типов элементов управления: `QLabel, QPushButton, QCheckBox, QLineEdit, QTextEdit, QSpinBox`, и т.п. Каждый из них может послужить базовым классом для собственного элемента управления, поведение которого может быть кастомизировано.

## <a name="r3">Модели и Представления</a>
Для отображения и управления большим количеством данных (списки, таблицы, деревья) в `Qt` поощряется использование способа под названием **Модель/Представление (Model/View)**. В отличие от **MVC (Model-View-Controller)** наличие контроллера здесь не всегда обязательно. Для простого отображения данных достаточно иметь модель с данными и представление, которое просто показывает эти данные.  

В случае, если нужно изменить данные посредством представления (например, пользователь кликнул на элементе таблицы) создают **«делегат»**, который займется обработкой измененных данных и передаст результат модели. Делегат также нужен для отрисовки собственных (необычных) элементов и обработки событий, которые происходят с элементами (например, клик на определенной области или выделение отображаемого текста на элементе). Элементом Представления считается 1 ячейка таблицы. В модели списка будет использоваться таблица с количеством столбцов равным 1, а в модели дерева элемент таблицы имеет указатель на родительский элемент. В любом из этих случаев модель имеет дело с одним и тем же абстрактным типом элементов, которые идентифицируются по столбцу, строке и родительскому индексу.  

Таким образом, одна модель данных может использоваться в различных Представлениях. Например: модель содержит данные древовидной структуры. Все данные модели могут отображаться в одном Представлении типа [QTreeView](https://doc.qt.io/archives/qt-4.8/qtreeview.html). Каждый из родительских элементов может быть отображен в отдельной таблице [QTableView](https://doc.qt.io/archives/qt-4.8/qtableview.html). А, скажем, свойства каждого элемента таблицы могут быть отображены в списке [QListView](https://doc.qt.io/qt-5/qlistview.html). Таким образом, имея одну модель, мы можем отображать разные части её данных в разных Представлениях, причем одновременно, к тому же изменения модели отражаются сразу во всех Представлениях.

## <a name="r4">Многопоточность</a>

### [QThread](https://doc.qt.io/archives/qt-4.8/qthread.html#QThread)
Класс-обертка над системным потоком. Позволяет выполнять код объекта в контексте своего потока. Метод
`void QObject::moveToThread(QThread *targetThread)`
выполняет перемещение контекста объекта в другой логический поток. Управление объектом в потоке происходит посредством вызовов слотов объекта-потока `QThread` (например, вызовом слота `start()` или другого слота, добавленного в производном классе) или объекта, выполняющегося в этом потоке.

Традиционный способ выполнения кода в отдельном потоке сводится к переопределению protected-метода `QThread::run()`. В этом методе можно написать код, который начнет выполняться после вызова метода объекта-потока `QThread::start()`.

Существует и другой способ выполнения кода в контексте `QThread` – это использование метода `QObject::moveToThread`. В этом случае нужно создать класс-“`runner`” со слотом, в котором будет выполняться код, и связать этот слот с сигналом, доступным в первом потоке. После выполнения кода в слоте объект-«`runner`» можно удалить.

### [QtConcurrent](https://doc.qt.io/qt-5/qtconcurrent-module.html)
Модуль `Qt` со своим пространством имен, в котором реализован функционал асинхронного вызова функций. Концепция построена так же, как у функционала для асинхронных вызовов из C++11. Реализация основана на использовании внутреннего пула потоков (`QThreadPool`), в который добавляются задачи, которые должны быть выполнены асинхронно. `QtConcurrent` использует сущность `QFuture` (похож на `std::future`), объекты которой содержат результаты отложенных вычислений. В отличие от реализации `future` из `STL`, у `QFuture` есть возможность приостановить и продолжить вычисления. По аналогии с `std::async` здесь есть метод `QtConcurrent::run`. `QFutureWatcher` позволяет следить за процессом сразу нескольких отложенных вычислений и управлять этим процессом. В целом `QtConcurrent` – это большой модуль, предоставляющий массу новых возможностей и не зависящий от версии стандарта `C++`, с помощью которого происходит разработка.

## <a name="r5">События</a>

События в `Qt` - это объекты специализированных классов, унаследованных от `QEvent`. Обработчики событий – это функции наследников класса `QObject`, которые принимают определенные типы событий и созданы для того, чтобы предпринимать какие-то действия над своим объектом в зависимости от информации, переданной в объекте-событии. Если событие не может быть обработано объектом, который его принял, такое событие передается владеющему объекту, пока не достигнет уровня `QApplication`.

##### Примеры обработчиков событий в классе QWidget:
~~~C++
void QWidget::mousePressEvent(QMouseEvent * event)
void QWidget::resizeEvent(QResizeEvent * event)
void QWidget::keyReleaseEvent(QKeyEvent * event)
~~~
Эти обработчики вызываются оконной системой, когда с виджетом выполняются определенные действия, описанные в названии обработчика. Архитектура классов `Qt` позволяет переопределять методы обработчиков, чтобы позволить разработчику перехватывать определенные события и выполнять специфические действия в зависимости от ситуации.

Универсальным обработчиком является метод
~~~C++
bool QObject::event(QEvent *e)
~~~
Он позволяет перехватывать события любого типа. Возвращаемое значение определяет, было ли событие обработано должным образом (`true`) или не было и его нужно передать другому объекту (`false`).

## <a name="r6">Сигналы и слоты</a>

Сигналы и слоты используются для коммуникации между объектами. Сигнал вырабатывается когда происходит определенное событие. Слот это функция, которая вызывается в ответ на определенный сигнал. Виджеты Qt имеют много предопределенных сигналов и слотов, но мы всегда можем сделать дочерний класс и добавить наши сигналы и слоты в нем. 
~~~C++
emit SignalExample(); //отправка сигнала
QObject::connect(&emitter, &Emitter::SignalExample, &receiver, &Receiver::SlotExample); // привязка слота для обработки сигнала
~~~

## <a name="r7">Литература:</a>
### Онлайн-документация:
- https://doc.qt.io/qt.html
- О событиях: http://wiki.qt.io/Threads_Events_QObjects
- О Моделях и Представлениях: http://doc.qt.io/qt-5/modelview.html

### Книги:
- Бланшет, Саммерфилд, «Qt 4: программирование GUI на C++»
- Шлее М., «Qt 5.10 Профессиональное программирование на C++»
