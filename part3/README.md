# Управление ресурсами (Resource Management)
## Оглавление
1. [What is a resource?](#r1)
2. [Кто управляет ресурсами?](#r2)
3. [Иерархия ресурсов](#r3)
4. [Управление ресурсами на каждый день](#r4)
5. [Управление памятью](#r5)

## <a name="r1">What is a resource?</a>
In computing science, resource is a primitive that is used in computing.  
В информатике ресурс - это примитив, который используется для проведения вычислений.

Из такого определения у вас может возникнуть вопрос: но ведь большая часть того, что содержится в системном блоке так или иначе используется в вычислениях. 
И я вам отвечу: да, и даже больше, чем там есть.  

Больше, потому что ресурсы бывают физическими и виртуальными. *Физические ресурсы* это составляющие компьютера, выполняющие свои узкопрофильные задачи. *Виртуальные* - это ресурсы, не имеющие непосредственного представления в нашем мире. Мы не можем их потрогать, однако они построены поверх физических, образуя некую иерархию.  

Примером физических ресурсов являются процессор, память, жесткий диск.  
Примером виртуальных ресурсов является файл, мьютекс и виртуальная память, которая выделяется процессу операционной системой.  

Выделим также такой ресурс как время. Его мы будем рассматривать почти всегда, где бы мы не находились в этой самой иерархии.  

## <a name="r2">Кто управляет ресурсами?</a>
Вернемся в прошлое на 35 лет назад. Консоли - основной способ прикоснуться к видеоиграм, которые уже успели стать новой неотъемлимой частью искусства.  
Вот краткая схема того, как выглядело внутреннее устройство NES
![image_3_1](https://github.com/sotnikea/Internship_Apriorit/raw/main/part3/img/pic_3_1.png)  
 
Цикл использования NES был довольно простым: приставка ожидает картридж, после его присоединения, считывает программу игры и необходимые ресурсы (например: спрайты и строки текста), после чего обрабатывает ввод с геймпада и отрисовывает картинку.  

Уточняя вопрос, кто занимается управлением ресурсов: кто управляет всем тем, что я перечислил выше?  

По большей части программист. Не прямо в процессе игры, конечно. Но они должны были обеспечить взаимодействие всех этих компонентов в своей программе, которая хранится на картридже. Речь об операционных системах на приставках не идет. По сути, каждый катридж идет с игрой, которая и является операционной системой, которая управляет всеми ресурсами приставки.  

Каким образом программист управляет ресурсами NES? Рассмотрим только вывод картинки на экран. Начнем с того, что у программиста был только один инструмент - это язык ассемблера, который поддерживала NES. Он довольно прост, содержит минимум инструкций, но представьте себе, каково это писать игрушку на ассемблере.  

Окей, у нас есть язык, что дальше? С помощью языка мы уже можем задействовать такой ресурс как процессор. Дальше надо знать, как именно можно задействовать все остальные ресурсы приставки в игре. Такими ресурсами выступают: память, постоянная память картриджа, видеопамять. Все они соединены с процессором по шине памяти.
![image_3_2](https://github.com/sotnikea/Internship_Apriorit/raw/main/part3/img/pic_3_2.png)  
 
##### *Картинка взята с видео: NES Emulator Part #1: Bitwise Basics & Overview - YouTube*  

На картинке видно, что для того, чтобы получить доступ к памяти картриджа, нужно всего лишь обратиться к нему по адресу. Инструкции ассемблера в основном состоят из манипуляций памятью. А именно, чтение и запись. Поэтому, если нам надо скопировать спрайт из картриджа, мы просто обращаемся к той памяти, где у нас лежит спрайт, относительно начала картриджа + адрес памяти, куда у нас маппится картридж. Пример. Пусть нам надо загрузить в память (RAM) какой-нибудь объект, который располагается на картридже по адресу x50. Мы сначала узнаем адрес, где у нас расположен катридж на шине - x4020. А затем прибаляем адрес объекта. Получаем x4070.  

Соответственно, для того, чтобы отрисовать этот объект, нам надо будет скопировать его в VRAM (видеопамять), содержимое которой - это просто набор пикселов, который отрисовывается на экране с определенной частотой.  

Подход очень простой. Казалось бы, зачем идти дальше, если можно ограничиться манипуляцией данных на шине. Любую программу можно написать таким способом.  

Проблемой такого подхода является непрозрачность для программиста, неперносимость и большая цена ошибки. Как же нам этого избежать?  

Приблизительно в то же время уже была развита сфера персональных компьютеров, которые были гораздо сложнее в своем устройтве, чем 8битная приставка. И далеко не с аппаратной части. Всё дело в операционных системах. Они предоставляют более изящный способ управлять ресурсами, что значительно облегчило жизнь программистов.  

## <a name="r3">Иерархия ресурсов.</a>
Рассмотрим жесткий диск. Допустим, вам надо считать файл и вывести его содержимое в стандартный вывод терминала. Если бы вам пришлось всю эту работу проделывать самому, без поддержки ОС, то вы бы бросили эту затею еще на попытке что-то прочесть из файла, не дойдя до вывода. Давайте посмотрим, что ж там происходит под капотом:
![image_3_3](https://github.com/sotnikea/Internship_Apriorit/raw/main/part3/img/pic_3_3.png)  
 
ОС абстрагирует файловую систему и драйвер.

![image_3_4](https://github.com/sotnikea/Internship_Apriorit/raw/main/part3/img/pic_3_4.png) 
 
Поэтому, когда мы пишем подобные программы, у нас есть удобный интерфейс для работы с данными, которые являются надсткойкой над файловой системой: open, read, write, close и тд.  

Кроме подобной абстракции, ОС реализует и основные защитные механизмы: разделение по времени и разделение по пространству (по памяти).  

Эти механизмы актуальны для многозадачных ОС, которые поддерживают работу сразу нескольких процессов. Они направлены на то, чтобы области памяти, в которых работают программы, были изолированы друг от друга, и чтобы состояния программ после переключения контекста, не перемешивались, а оставались валидными.  

Теперь, когда мы разобрались, какие бывают ресурсы, и кто ими управляет, перейдем к тем ресурсам, которые встречаются программисту почти каждый день - это память, некоторые ресурсы ОС и время.  

Управление таким ресурсом как время, вы увидите в лекции про многопоточность. По сути, вам покажут как создавать и синхронизировать программные потоки. Своего рода механизм разделения ответственности по времени - это набор взаимных блокировок, когда два потока не должны одновременно читать и писать (или одновременно писать) в один и тот же участок памяти.  

## <a name="r4">Управление ресурсами на каждый день</a>
Как правило, перед тем, как использовать какой-либо ресурс, нужно попросить зарезервировать этот ресурс за нашим процессом. Например, таким резервированием является открытие файла, создание мьютекса, сокета или выделение памяти. Резервация или же овладевание ресурсом просто дают ОС знать, что он используется определенным процессом. Если иной процесс захочет получить доступ к ресурсу, который уже используется другим процессом, то ОС может разрешить или не разрешить ему это делать, в зависимости от того, какой тип владения используется. Например, ОС не выделит один и тот же кусок памяти для двух процессов. Однако, может разрешить читать одновременно из нескольких файлов.  

В си управление ресурсами полностью возлагается на разработчика. Рассмотрим процесс выделения памяти.  
~~~C++
int* a = malloc(sizeof(int)); // выделили память под int на куче
~~~
Если после этого вызова, мы потеряем доступ к a, а память не освободим, у нас произойдет утечка памяти. Отследить и устранить ее нельзя (во всяком случае, разумными средствами). Только через рестарт программы.  

Или же рассмотрим файл
~~~C++
int f = open(“path/to/file.txt”, O_CREAT);
~~~
Если после этого не последует close, а доступ к f будет потерян, то файл будет числиться открытым за этим процессом до самого его завершения.  

Поэтому в Си после захвата ресурсов должно последовать и их явное освобождение.  

Казалось бы, проблема ясна, решение просто - следим за парными вызовами и всё.
Возможно. До тех пор, пока вы не столкнетесь с ветвлениями. А ведь еще есть циклы.  

Но мы живем в современном мире, где нам не хочется обременять себя такими скучными вещами как освобождение ресурсов вручную. Поэтому, в таком языке как с++, где у нас есть волшебная функция с брутальным названием деструктор, мы можем позволить себе решить эту проблему более изящным путём. А именно - создать гварды.   

Существуют гварды и в стандартной библиотеке c++:
~~~C++
unique_ptr, shared_ptr, weak_ptr - для памяти
lock_guard, unique_lock, shared_lock - для мьютексов
fstream - можно сказать тоже гвард, так как закрывает файл хэндл по закрытию
~~~

## <a name="r5">Управление памятью</a>
Современный C++ позволяет почти полностью абстрагироваться от выделения памяти собственноручно, снимая с программиста отвественность освобождать ее, тем самым облегчив его работу.  

### **Unique-ptr**
- Выделяет память под значение и коструирует там объект. Или же овладевает сырым указателем (лучше избегать).  
- Эксклюзивное владение. Всегда гарантирован только один владелец. Как он этого добивается? Запрещены копии.  
- Передача владения через `move` семантику. Главное отличие от копирования заключается в том, что мув для `l-value` значений всегда производится явно. Что убережет программиста от случайной передачи владения. 

### **Shared-ptr**
- Раздельное владение. Позволяет владеть сразу нескольким объектам.  
- Удаляет ресурс только тогда, когда не остается ни одного владельца.  
- Ведет счетчик ссылок.  
-Ведет счетчик слабых ссылок.  

### **Weak-ptr**
- Не владеет ресурсом.
- Ссылается только на контрольный блок shared-ptr. Имеет возможность получить владение, создав новый shared-ptr объект.
- И просто очень милый:)
