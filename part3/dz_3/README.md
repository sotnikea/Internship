# Условие первого задания
Реализовать класс, который будет представлять собой гвард для `FILE` хэндла.

** Добавить возможность использовать кастомный `deleter` и адаптировать класс для хранения любых ресурсов (сделать, чтобы можно было хранить как `FILE`, так и `socket handle`, например)

# Условие второго задания
Написать функцию, которая добавляет в вектор какие-либо значения с таким объявлением:
~~~C++
void foo(std::vector<int>& v) {
	// your code
}
~~~
Реализовать **строгую гарантию безопасности**, с учетом всех исключений, которые могут бросать операции вектора, которые вы используете.

# Формат сдачи
Загрузить `cpp` файлы готовых решений


# Обзор решения
*Задание 1*
Суть решения заключается в реализации механизма, способного самостоятельно закрывать открытый ранее файл, если связь указателя с ним утеряна.  
Для этого реализован класс `HandleGuard` содержащий в себе указатель типа `FILE`:
~~~C++
private:
	FILE *m_fptr;
~~~
инициализируемый собственно указателем на ранее открытый файл:
~~~C++
HandleGuard(FILE *fptr):m_fptr(fptr){}
~~~
А так же деструктор, закрывающий файл при его выходе из области видимости
~~~C++
~HandleGuard() {
	fclose(m_fptr);
}
~~~

*Задание 2*  
Строгая гарантия предполагает, что состояние вектора, переданного в функцию
~~~C++
void foo(std::vector<int>& v)
~~~
в случае возникновения исключения не изменится и останется таким же, как до передачи в функцию.  
Чтобы восстановить состояние вектора в случае исключения, копируем его 
~~~C++
std::vector<int> origin(v);
~~~
Одним из вариантов исключения может быть попытка обратиться к элементу вектора по индексу используя метод at. На этот случай помещаем цикл с итерированием по вектору в блок `try`
~~~C++
try {
	//some operation with method at		
	v.at(index_out_of_vector) = val;	
}		
~~~
Ловим это исключение внутри функции с помощью блока `catch`:
~~~C++
catch (std::out_of_range& ex){
	//some code...
}
~~~
Восстанавливаем первоначальное состояние вектора заменяя в нем значения на скопированные ранее
~~~C++
v.assign(origin.begin(), origin.end());
~~~
И пробрасываем исключение наружу с помощью `throw`, как это требуется по условию задания.  
Для всех возможных исключений отличных `std::out_of_range` используем `catch(...)`

~~~C++
catch (...) {		
	v.assign(origin.begin(), origin.end());
	throw;
}
~~~
Естественно `main` так же содержит блок `catch`, чтобы ловить проброшенные исключения

# Оценка результата  
80 из 100  
[Ошибки в реализации и внесенные исправления](dz_3_new/)
