# Умови
1. Зробити оцінку складності алгоритму за кодом
~~~C++
void func(int[] A, int low, int high) 
{
      int i = low;                
      int j = high;
      int x = A[(low+high)/2];      
      do {
          while(A[i] < x) ++i;  
          while(A[j] > x) --j;  
          if(i <= j)
	  {           
              int temp = A[i];
              A[i] = A[j];
              A[j] = temp;
              i++; j--;
          }
      } 
      while(i < j);
      if(low < j) //recursion
         func(A, low, j);
      if(i < high) //recursion
         func(A, i, high);
  }
~~~

2. Виберіть найбільш підходящий контейнер для збереження інформації телефонного довідника. Мається на увазі, що довідник дозволяє знайти інформацію про абонента за номером. Обґрунтуйте вибір певного контейнера. Обгрунтування передбачає приведення списку операцій, що найбільш часто застосовуються для цього контейнера, і оцінок їх складностей по O нотації.

# Формат здачі
Звичайний текстовий документ з поясненням до кожної задачі або посилання на гіт з оглядом рішення

# Огляд рішення
### *Завдання 1*
Зазначений код є алгоритмом [швидкого сортування](https://en.wikipedia.org/wiki/Quicksort).  
Згідно [документації](https://www.bigocheatsheet.com/) його складність в найгіршому випадку буде **О(n<sup>2</sup>)**.  
В середньому (найбільш вірогідному випадку) **О(n log(n))**. 
___
### *Завдання 2*
Враховуючи умови завдання, можна припустити, що найчастішими операціями з телефонним довідником будуть(у вказаному порядку): 
- Пошук за номером
- Додавання нового запису
- Видалення запису

Враховуючи високу інтенсивність пошукових операцій, найбільш ефективними варто виокремити наступні контейнери:
- Відсортований `std::vector`
- Асоціативний контенер `std::map`
- Хеш-контейнер `std::unordered_map`

Оскільки пошук в довіднику планується за номером, варіант з відсортованим `std::vector` втрачає свою ефективність, оскільки неможливо буде скористатися доступом до елемента за індексом.   
Таким чином пошук елемента завжди буде мати складність **O(n)**. Додання та видалення елемента також **O(n)**.

Порівняємо `std::map` та `std::unordered_map`. Згідно з [документацією](https://www.bigocheatsheet.com/), контейнери мають наступну складність:  

**`std::map`**:
| Операція | Average Time Complexity | Worst Time Complexity |
| -------- | ----------------------- | --------------------- |
|  Пошук   | O(log(n))               | O(log(n))             |
|Додавання | O(log(n))               | O(log(n))             |
|Видалення | O(log(n))               | O(log(n))             |

**`std::unordered_map`**:
| Операція | Average Time Complexity | Worst Time Complexity |
| -------- | ----------------------- | --------------------- |
|  Пошук   | O(1)                    | O(n)                  |
|Додавання | O(1)                    | O(n)                  |
|Видалення | O(1)                    | O(n)                  |


Як бачимо `std::map` незалежно від ситуаціє надає складність **log(n)**, тоді як `std::unordered_map` має розбіг від **O(1)** в середньому до **O(n)** в найгіршому випадку.  

На цьому можна було б зробити вибір на користь `std::map`, що дає трохи більший за середній у `std::unordered_map`, але стабільний рівень складності. Та все ж варто проаналізувати контекст в якому буде використовуватись контейнер, а також причини, за яких `std::unordered_map` дає складність вищу за **O(1)**.

Згідно з ["Working Draft, Standard for Programming Language C++"](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf) розділ 23.5.4.3 та 23.5.4.4 складність **O(n)** виникає лише в випадках, коли в контейнер додається ключ, що вже в ньому існує.   
При цьому, згідно з умовами технічного завдання, пошук в контейнері проводиться лише за номером телефону. Тобто ключем в довіднику буде номер телефону, який є унікальним для кожної окремої особи і ситуації додавання двох осіб з однаковим номером телефону виключені.  
Таким чином пошук, додавання та видалення в контейнері завжди матиме константну складність **O(1)**, що ефективніше ніж у `std::map`.

Враховуючи вищесказане, а також той факт, що в умовах технічного завдання не накладалися обмеження на кількість пам'яті (`std::unordered_map` потребує більше пам'яті аніж `std::map`). Та вважаючи малоймовірной ситуацію, з необхідністю роздрукування всього довідника за алфавітом (`std::unordered_map` не сортує елементи) контейнер `std::unordered_map` є найбільш підходящим контейнером для збереження інформації телефонного довідника.

# Посилання
Оцінка складності алгоритмів з прикладами - https://www.youtube.com/watch?v=ZRdOb4yR0kk  
Стаття на хабрі - https://pro-prof.com/archives/4275   
Working Draft, Standard for Programming Language C++ - https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf
