# Тема
## Оглавление
1. [Абстрагування даних та розв’язання задач. STL](#r1)
    - [Абстракція даних ](#r1_1)
    - [Оцінка складності алгоритму](#r1_2)
2. [Основні порядки складності алгоритмів у порядку зростання.](#r2)
    - [Константна складність](#r2_1)
    - [Логарифмічна складність](#r2_2)
    - [Лінійна складність](#r2_3)
    - [Лінійно-логарифмічна складність](#r2_4)
    - [Квадратична складність](#r2_5)
    - [Експоненційна складність](#r2_6)
3. [Основи STL](#r3)
    - [Бібліотека STL ](#r3_1)
    - [Контейнери](#r3_2)
    - [Послідовні контейнери](#r3_3)
    - [Асоціативні впорядковані контейнери ](#r3_4)
    - [Неупорядковані асоціативні контейнери ](#r3_5)
    - [Контейнери-рядки](#r3_6)
    - [Ітератори](#r3_7)
    - [Алгоритми в STL](#r3_8)

4. [Додаткові матеріали](#r4)

## <a name="r1">Абстрагування даних та розв’язання задач. STL</a>
### <a name="r1_1">Абстракція даних </a>
**Абстракція даних** – в контексті цієї лекції це не термін з об'єктно-орієнтованого програмування - це винахід нових підходів і структур даних, покликаних покращити ефективність найбільш часто застосовуваних базових алгоритмів. Будуть розглянуті найбільш базові алгоритми (сортування та пошук) та структури даних (дерева бінарного пошуку та хеш таблиці) та введено поняття О-нотації.

Будь-яке завдання в галузі програмування можна вирішити нескінченно великою кількістю алгоритмів. У зв'язку з цим досить давно постало завдання порівняння ефективності різних алгоритмів. Під ефективністю в даному контексті розуміють меншу кількість ітерацій і менший час роботи алгоритму. У зв'язку з цим виникло поняття O-нотації, що дозволяє нам порівнювати ефективність різних алгоритмів.

### <a name="r1_2">Оцінка складності алгоритму</a>
**Часова асимптотична складність. O-нотація.**  
У разі коли виконання алгоритму А прямо пропорційно функції f(n) кажуть, що алгоритм має складність порядку f(n), позначається цей факт, як O(f(n)) – O від order – порядок. Слід зазначити, що в базовому випадку складність алгоритму (залежність кількості необхідних операцій від кількості елементів) є надійним показником складності алгоритму. Але при цьому не слід спиратися тільки на неї, тому що не функціональна складність теж грає велику роль, наприклад простота складання, реалізації, супроводу алгоритму в деяких випадках навіть більш важливі.

## <a name="r2">Основні порядки складності алгоритмів у порядку зростання.</a>
~~~
O(1) < O(log2 n) < O(n) < O(nlog2 n ) < O(n2) < О(n3) < O(2n)
~~~
### <a name="r2_1">Константна складність</a>
**O(1)**. Константа 1 означає, що час виконання алгоритму постійно і, отже, не залежить від розміру задачі.  
**Приклад**: отримання елемента за адресою в масиві, або обчислення хеш функції блоку даних заданого розміру;

### <a name="r2_2">Логарифмічна складність</a>
**O(log2 n)**. Час виконання логарифмічного алгоритму (logarithmic algorithm) повільно зростає із збільшенням розміру задачі. Якщо розмір завдання зводиться в квадрат, його складність збільшується лише вдвічі. Зазвичай логарифмічні алгоритми вирішують завдання, зводячи її до меншого розміру. Підстава логарифму впливає складність алгоритму, тому його можна не вказувати.  
**Приклад**: бінарний пошук у відсортованому масиві. Нагадаємо, що при бінарному пошуку масив ділиться навпіл, а потім пошук продовжується в одній із отриманих половин масиву.

### <a name="r2_3">Лінійна складність</a>
**O(n)**. Час виконання лінійного алгоритму (linear algorithm) прямо пропорційний розміру задачі. Якщо розмір завдання зводиться в квадрат, обсяг часу збільшується так само.  
**Приклад**: Фільтрування - коли нам потрібно обійти всі елементи колекції та визначити, чи задовольняють вони нашим вимогам. Чим більше елементів – тим більше перевірок.

### <a name="r2_4">Лінійно-логарифмічна складність</a>
**O(nlog2 n)**. Час виконання алгоритму, що має складність O(nlog2 n), зростає швидше, ніж у лінійного алгоритму. Такі алгоритми зазвичай розбивають завдання на підзавдання та вирішують їх окремо.   
**Приклад**:  сортування злиттям (merge sort) або швидке сортування (quick sort).

### <a name="r2_5">Квадратична складність</a>
**O(n^2^)**. Час виконання квадратичного алгоритму (quadratic algorithm) швидко зростає зі збільшенням розміру задачі. В алгоритмах такого типу часто використовуються два вкладені цикли. Такі алгоритми слід застосовувати лише на вирішення невеликих завдань.
Приклад: сортування бульбашкою (bubble sort) для найгіршого випадку.

### <a name="r2_6">Експоненційна складність</a>

## <a name="r3">Основи STL</a>
### <a name="r3_1">Бібліотека STL </a>
### <a name="r3_2">Контейнери</a>
### <a name="r3_3">Послідовні контейнери</a>
### <a name="r3_4">Асоціативні впорядковані контейнери </a>
### <a name="r3_5">Неупорядковані асоціативні контейнери </a>
### <a name="r3_6">Контейнери-рядки</a>
### <a name="r3_7">Ітератори</a>
### <a name="r3_8">Алгоритми в STL</a>


## <a name="r4">Додаткові матеріали</a>


