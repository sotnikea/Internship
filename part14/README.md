# Тема
## Оглавление
1. [Абстрагування даних та розв’язання задач. STL](#r1)
    - [Абстракція даних ](#r1_1)
    - [Оцінка складності алгоритму](#r1_2)
2. [Основні порядки складності алгоритмів у порядку зростання.](#r2)
    - [Константна складність](#r2_1)
    - [Логарифмічна складність](#r2_2)
    - [Лінійна складність](#r2_3)
    - [Лінійно-логарифмічна складність](#r2_4)
    - [Квадратична складність](#r2_5)
    - [Експоненційна складність](#r2_6)
3. [Основи STL](#r3)
    - [Бібліотека STL ](#r3_1)
    - [Контейнери](#r3_2)
    - [Послідовні контейнери](#r3_3)
    - [Асоціативні впорядковані контейнери ](#r3_4)
    - [Неупорядковані асоціативні контейнери ](#r3_5)
    - [Контейнери-рядки](#r3_6)
    - [Ітератори](#r3_7)
    - [Алгоритми в STL](#r3_8)

4. [Додаткові матеріали](#r4)

## <a name="r1">Абстрагування даних та розв’язання задач. STL</a>
### <a name="r1_1">Абстракція даних </a>
**Абстракція даних** – в контексті цієї лекції це не термін з об'єктно-орієнтованого програмування - це винахід нових підходів і структур даних, покликаних покращити ефективність найбільш часто застосовуваних базових алгоритмів. Будуть розглянуті найбільш базові алгоритми (сортування та пошук) та структури даних (дерева бінарного пошуку та хеш таблиці) та введено поняття О-нотації.

Будь-яке завдання в галузі програмування можна вирішити нескінченно великою кількістю алгоритмів. У зв'язку з цим досить давно постало завдання порівняння ефективності різних алгоритмів. Під ефективністю в даному контексті розуміють меншу кількість ітерацій і менший час роботи алгоритму. У зв'язку з цим виникло поняття O-нотації, що дозволяє нам порівнювати ефективність різних алгоритмів.

### <a name="r1_2">Оцінка складності алгоритму</a>
**Часова асимптотична складність. O-нотація.**  
У разі коли виконання алгоритму А прямо пропорційно функції f(n) кажуть, що алгоритм має складність порядку f(n), позначається цей факт, як O(f(n)) – O від order – порядок. Слід зазначити, що в базовому випадку складність алгоритму (залежність кількості необхідних операцій від кількості елементів) є надійним показником складності алгоритму. Але при цьому не слід спиратися тільки на неї, тому що не функціональна складність теж грає велику роль, наприклад простота складання, реалізації, супроводу алгоритму в деяких випадках навіть більш важливі.

## <a name="r2">Основні порядки складності алгоритмів у порядку зростання.</a>

O(1) < O(log<sub>2</sub> n) < O(n) < O(nlog<sub>2</sub> n ) < O(n<sup>2</sup>) < О(<sup>3</sup>) < O(2<sup>n</sup>)

### <a name="r2_1">Константна складність</a>
**O(1)**. Константа 1 означає, що час виконання алгоритму постійно і, отже, не залежить від розміру задачі.  
**Приклад**: отримання елемента за адресою в масиві, або обчислення хеш функції блоку даних заданого розміру;

### <a name="r2_2">Логарифмічна складність</a>
**O(log<sub>2</sub> n)**. Час виконання логарифмічного алгоритму (logarithmic algorithm) повільно зростає із збільшенням розміру задачі. Якщо розмір завдання зводиться в квадрат, його складність збільшується лише вдвічі. Зазвичай логарифмічні алгоритми вирішують завдання, зводячи її до меншого розміру. Підстава логарифму впливає складність алгоритму, тому його можна не вказувати.  
**Приклад**: бінарний пошук у відсортованому масиві. Нагадаємо, що при бінарному пошуку масив ділиться навпіл, а потім пошук продовжується в одній із отриманих половин масиву.

### <a name="r2_3">Лінійна складність</a>
**O(n)**. Час виконання лінійного алгоритму (linear algorithm) прямо пропорційний розміру задачі. Якщо розмір завдання зводиться в квадрат, обсяг часу збільшується так само.  
**Приклад**: Фільтрування - коли нам потрібно обійти всі елементи колекції та визначити, чи задовольняють вони нашим вимогам. Чим більше елементів – тим більше перевірок.

### <a name="r2_4">Лінійно-логарифмічна складність</a>
**O(nlog<sub>2</sub> n)**. Час виконання алгоритму, що має складність O(nlog2 n), зростає швидше, ніж у лінійного алгоритму. Такі алгоритми зазвичай розбивають завдання на підзавдання та вирішують їх окремо.   
**Приклад**:  сортування злиттям (merge sort) або швидке сортування (quick sort).

### <a name="r2_5">Квадратична складність</a>
**O(n<sup>2</sup>)**. Час виконання квадратичного алгоритму (quadratic algorithm) швидко зростає зі збільшенням розміру задачі. В алгоритмах такого типу часто використовуються два вкладені цикли. Такі алгоритми слід застосовувати лише на вирішення невеликих завдань.  
**Приклад**: сортування бульбашкою (bubble sort) для найгіршого випадку.

### <a name="r2_6">Експоненційна складність</a>
**O(2<sup>n</sup>)**. Зі збільшенням розміру завдання час виконання експоненціального алгоритму (exponential algorithm) різко зростає, тому такі алгоритми застосовуються рідко.

## <a name="r3">Основи STL</a>
### <a name="r3_1">Бібліотека STL </a>
**Бібліотека STL** це набір узгоджених узагальнених алгоритмів, контейнерів, засобів доступу до їхнього вмісту та різних допоміжних функцій у C++. STL реалізує більшість загальновживаних алгоритмів та структур даних.  
STL гарантовано портабельна, тобто її не потрібно портувати під різні OS.  
Склад STL:
- Контейнери
- Ітератори
- Алгоритми
- Функтори
- Потоки (IO)
- Різне (unique_ptr, limits, …)

### <a name="r3_2">Контейнери</a>
Призначені для керування колекціями об'єктів довільного типу. Досягається це за рахунок шаблонів C++.  
Розрізняють два класи контейнерів:
1.	Послідовні (`vector`, `deque`, `list`, `string`)
2.	Асоціативні (`map`, `multimap`, `set`, `multiset`)

Контейнери дозволяють задавати власний розподільник пам'яті, тим самим надаючи можливість керувати виділенням та звільненням пам'яті під об'єкти.

### <a name="r3_3">Послідовні контейнери</a>
`std::vector` (вектор) є послідовним контейнером, який розташований у пам'яті монолітним блоком. Дозволяє використання як С масив. Необхідно виділення нової пам'яті та копіювання всіх елементів контейнера при перевищенні розміру монолітного блоку.  
`std::vector::reserve()` – установка мінімального розміру контейнера для запобігання перевиділення пам'яті при зростанні вмісту контейнера

`std::deque` (двостороння черга) являє собою послідовний індексований контейнер, який дозволяє швидко вставляти та видаляти елементи з початку та з кінця. Крім того, вставка та видалення з обох кінців двосторонньої черги залишає дійсними покажчики та посилання на інші елементи.  
*На відміну від std::vector, елементи дека не зберігаються безперервно: зазвичай реалізовано за допомогою набору виділених масивів фіксованого розміру.*

### <a name="r3_4">Асоціативні впорядковані контейнери </a>
`map`, `multimap`, `set`, `multiset`  
Впорядковані асоціативні контейнери – є можливість переведення елементів за зростанням або зменшенням значення ключа  
Вставка, пошук, видалення – для всіх випадків (кращого\гіршого\середнього) O(log n)  
Реалізація – дерево бінарного пошуку, що самобалансується, (чорно-червоне)

### <a name="r3_5">Неупорядковані асоціативні контейнери </a>
`unordered_map`, `unordered_set`, `unordered_multimap`,`unordered_multiset`.  
Пошук, видалення, вставка: O(1) у середньому, O(n) – у найгіршому випадку  
Більше витрати пам'яті порівняно з `set`/`map`/…  
Немає можливості перебрати вміст контейнера в певному порядку  
Всередині елементи організовані у комірках. В яку комірку потрапить елемент залежить від хеша ключа.  
Входять до стандарту з 2011 року

### <a name="r3_6">Контейнери-рядки</a>
`std::string` и `std::wstring` - аналоги вектора, що використовується переважно для символьних типів. Використовується для зберігання текстових даних у загальному випадку. Не гарантує послідовне розташування в пам'яті (до стандарту 2011 року) – хоча всі існуючі реалізації мали дані послідовно.  
Для конвертації в 0-термінований рядок є метод c_str().  

### <a name="r3_7">Ітератори</a>
**Ітератор** – об'єкт послідовного перебору елементів контейнера.  
Операції над ітераторами відповідають інтерфейсу стандартних вказівників.  
У всіх контейнерів є методи отримання ітераторів на вміст контейнера (`begin`, `end`, `rbegin`, `rend`, `cbegin`, `cend`, `crbegin`, `crend`);  
Ітератори для блокових контейнерів після вставки стають не валідними, для вузлових контейнерів цього не відбувається.  
Зі стандарту 2011 року контейнер з функціями доступу до послідовних ітераторів виведення begin та end можна обійти з використанням конструкції foreach  
~~~C++
for (const auto& element : container)
~~~

### <a name="r3_8">Алгоритми в STL</a>
**Сортування**
- `sort` – звичайне сортування
- `stable_sort` – зберігає відносний порядок однакових елементів
- `partial_sort` – часткове сортування
- `nth_element` - перемістити вибраний елемент на його позицію у відсортованій послідовності
- `partition` – перерозподіляє елементи в послідовності таким чином, що елементи для яких вірна задана умова йдуть перед усіма іншими

**Пошук**
- `find` / `find_if` – пошук перебором за значенням чи предикатом
- `search` – знаходження підпослідовності
- `lower_bound` / `binary_search` / `equal_range` – бінарний пошук у впорядкованій послідовності

**Функтори**  
Функтор – об'єкт, який поводиться як покажчик на функцію.   
Предикати – функтори, які повертають bool

## <a name="r4">Додаткові матеріали</a>
Опис стандартної бібліотеки: 
- http://www.cplusplus.com/
- https://en.cppreference.com/w/ 

Шпаргалки:
- https://www.bigocheatsheet.com/

О-нотация и сложность алгоритмов:
- https://habrahabr.ru/post/104219/
- http://discrete.gr/complexity/

С++ и STL:
- Scott Meyers. Effective STL (ISBN 0-201-74962-9)
- Scott Meyers. Effective С++ (ISBN  0-201-56364-9, 0-201-63371-X, 0-321-33487-6, 1-491-90399-6)  




