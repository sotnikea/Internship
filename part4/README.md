# Modern & Effective C++
## Оглавление
1. [R-value and L-value](#r1)
2. [Moving](#r2)
3. [Universal-reference (forwarding reference)](#r3)
    - [Правило особого вывода (special type deduction rules)](#r3_1)
    - [Правила сворачивания ссылок (reference collapsing rules)](#r3_2)
4. [Perfect forwarding](#r4)
5. [Special members](#r5)
6. [Вопросы/ответы](#r6)
7. [Материалы по неопределенному поведению](#r7)
8. [Квалификаторы в std::function](#r8)
9. [Комментарий по результатам проверки домашнего задания](#r9)



## <a name="r1">R-value and L-value</a>
**L-value (left)** – объект, который сохраняется существует после вычисления выражения. Такой объект имеет имя. Таким образом все переменные – это l-value.  
**R-value (right)** – временный объект, который не сохраняется после вычисления выражения в котором он используется.  

Пример:
~~~C++
auto x = 1.5 + 0.2
auto result = std::sin(x);
~~~

Значения в переменных `x` и `result` – это l-values. К этим значениям можно обратится по имени. Значения 1.5 + 0.2 и `std::sin(x)` – это r-values, которые представляют временные объекты. R-values не обязательно находятся справа:
~~~C++
auto result(std::sin(x));
~~~

## <a name="r2">Moving</a>
Рассмотрим пример:  
~~~C++
store.push_back(std::string("Some string"));
~~~
До С++ 11:  
1.	Вызовется конструктор `std::string` с аргументом `"Some string"`.
2.	Вызовется метод `vector<string>::push_back(const value_type& _Val)`.
3.	Вызовется конструктор копирования `string::string(const string&)`.  

Чтобы избежать лишнего копирования в С++11 ввели операцию перемещения. В действительности, для передачи в функцию временного объекта строки, нет необходимости выделять новый участок памяти, и копировать старую строку в новый буфер: достаточно лишь переместить указатель на исходную строку:

С++ 11:
1.	Вызовется конструктор `std::string` с аргументом `"Some string"`.
2.	Вызовется метод `vector<string>::push_back(value_type&& _Val)`.
3.	Вызовется конструктор перемещения `string::(string&&)`.

Синтаксис **type&&** - обозначает **r-value** ссылку.  
**Обратите внимание:** Если r-value ссылка имеет имя, то она является l-value!

## <a name="r3">Universal-reference (forwarding reference)</a>
Универсальная ссылка – это ссылка, которая в зависимости от условий может быть, как r-value ссылкой, так и l-value ссылкой.
### <a name="r3_1">Правило особого вывода (special type deduction rules)</a>
Пусть имеется шаблонная функция 
~~~C++
template <typename T>
void Func(T&& arg)
{
    //some actions
}
~~~
В зависимости от того, что передается в `Func`, параметр `arg` может быть или lvalue ссылкой или rvalue. Правило, определяющие это, называются правилом особого вывода: 

>*Если Func вызывается для r-value, то arg будет r-value ссылкой; в случае же, когда Func вызывается для l-value, то arg будет l-value ссылкой.*

Рассмотрим следствия из этого правила на нескольких примерах:
~~~C++
    Func(int(0));
~~~
В этом примере в функцию передается r-value, а T выводится как int.
~~~C++
    int x = 0;
    Func(x);
~~~
В этом случае x – lvalue, поэтому arg – l-value-ссылка, а T выводится как int&.  
В зависимости от того, что передается l-value или r-value, имеет место различный вывод типа T.

### <a name="r3_2">Правила сворачивания ссылок (reference collapsing rules)</a>
`T&` и `&` становится `T&`  
`T&&` и `&` становится `T&`  
`T&` и `&&` становится `T&`  
`T&&` и `&&` становится `T&&`  

Из примера передачи в функцию `Func` переменной `x` (l-value) `T` выводится как `int&`. Имеет место сворачивание ссылки: 
~~~
void Func(int& &&arg)    =>    void Func(int& arg)
~~~

Сворачивания ссылок происходит в четырех контекстах:
-	вывод шаблонного типа
-	вывод `auto`
-	вывод `typedef`
-	в `decltype`.

**Понятие универсальной ссылки возникает лишь в контекстах, в которых происходит вывод типа.**

## <a name="r4">Perfect forwarding</a>
Рассмотрим фабричную функцию:  
~~~C++
template<typename T, typename Arg>
shared_ptr<T> Factory(Arg arg)
{
    return shared_ptr<T>(new T(arg));
}
~~~
Назначение приведенной фабричной функции – передать аргумент конструктору T. Недостаток функции – аргумент передается по значению, что приводит к лишнему копированию. 

Рассмотрим альтернативу:
~~~C++
template<typename T, typename Arg>
shared_ptr<T> Factory(Arg& arg)
{
    return shared_ptr<T>(new T(arg));
}
~~~
Теперь стало лучше, за одним исключением: функция не может быть вызвана для r-value: `Factory<Foo>(5)` и `Factory<Foo>("Some string")` приведут к ошибке компиляции. Эта ситуация может быть исправлена если дополнительно предоставить перегрузку для константной ссылки:

~~~C++
template<typename T, typename Arg>
shared_ptr<T> Factory(Arg const & arg)
{
    return shared_ptr<T>(new T(arg));
}
~~~

У такого подхода имеется две проблемы:  
- необходимо предоставлять две версии функции (для константной и не константной ссылки)
- аргумент в теле функции `Factory` – lvalue, а это блокирует move-семантику, что приводит к деградации производительности.

Выход есть - использование универсальных ссылок и perfect forwarding:
~~~C++
template<typename T, typename Arg>
shared_ptr<T> Factory(Arg&& arg)
{
    return shared_ptr<T>(new T(std::forward<Arg>(arg)));
}
~~~

`std::forward` – это шаблонная ф-ция стандартной библиотеки С++, которая реализована следующим образом:
~~~C++
template <typename T>
T&& forward(typename std::remove_reference<T>::type& arg)
{
    return static_cast<T&&>(arg);
}
~~~

Шаблонная функция `remove_reference` убирает декорирование типа ссылкой (т.е. для `int&` и `int&&` выведенный тип будет `int`).  
Используя правило особого вывода и правила сворачивания ссылок легко убедиться, что при передаче в Factory аргумента как l-value, в конструктор будет передана l-value ссылка, а при передаче r-value – в конструктор будет передана r-value ссылка, что позволит использовать перемещение.  
Чтобы получить rvalue ссылку на l-value следует использовать `std::move`:
~~~C++
template <typename T>
typename std::remove_reference<T>::type&& move(T&& arg)
{
    return static_cast<typename std::remove_reference<T>::type&&>(arg);
}
~~~
В следующем примере будет вызвана перемещающая перегрузка `push_back`:
~~~C++
std::vector<std::string> v;
std::string str = "Hello World!";
v.push_back(std::move(str));
~~~
**Используйте `std::forward` для универсальных ссылок (к примеру, в контексте шаблонной функции), а `std::move` для l-value ссылок.**

## <a name="r5">Special members</a>

| Метод                    | Реализация           |
| ------------------------ | -------------------- |
| Конструктор по-умолчанию | Widget::Widget();    |
|  Деструктор              | Widget::~Widget();   |
| Конструктор копирования  | Widget::Widget(const Widget&);   |
| Оператор присваивания    | Widget& operator= (const Widget&);    |
| Перемещающий конструктор | Widget::Widget(Widget&&);    |
| Перемещающее присваивание | Widget& operator=(Widget&&);    |

Перемещающие операции генерируются (при необходимости) для классов у которых выполняются три следующие условия: 
- в классе не объявлены никакие копирующие операции
- в классе не объявлены никакие перемещающие операции
- в классе не объявлен деструктор

**Рекомендация «большой тройки»:** Если объявлена хотя бы одна из трех операций – копирующий конструктор, копирующий оператор присваивания или деструктор, то должны быть объявлены все три операции.

**В базовых классах обычно объявляется виртуальный деструктор**, а, следовательно, это подавляет перемещающие операции. Чтобы базовый класс имел перемещающие операции их следует объявить явно:

~~~C++
class Base
{
public:
    virtual ~Base() = default;

    Base(Base &&) = default;
    Base& operator=(Base&&) = default;

    Base(const Base&) = default;
    Base& operator = (const Base&) = default;
};
~~~

## <a name="r6">Вопросы/ответы</a>
Вопрос:
>Как работает цикл "for each, in"

Ответ:
>"for each, in" имеет вид  
`for each (object var in collection_to_loop) {/===/}`  
Это кастомная реализация от майкрософт. И может использоваться только с их компилятором
https://docs.microsoft.com/en-us/cpp/dotnet/for-each-in?view=msvc-170  
Предпочтительнее использовать  
`for (auto var : collection_to_loop) {/---/ }`  
или  
`std::for_each(_InputIterator __first, _InputIterator __last, _Function __f);`

## <a name="r7">Материалы по неопределенному поведению</a>
Хочу посоветовать полезные материалы для тех, кто планирует дальше писать на C++  
"Путеводитель C++ программиста по неопределенному поведению"  
Там собран большой список примеров, как можно выстрелить себе в ногу. Зная их вы сможете избегать подобных случаев.
Это не относится к курсу, но чтиво довольно интересное.  
https://github.com/Nekrolm/ubbook 

## <a name="r8">Квалификаторы в std::function</a>
Интересная особенность `std::function` заключается в том,что она не
гарантирует, что принимаемые значения будут именно такие, как описано.  
Можно использовать функции или функторы с аргументами типов, для которых работают неявные преобразования.  
То же касается и квалификаторов `const` и `&`.  

Я сделал небольшой примерчик, чтоб было понятнее.  
Запустить его и поиграться со значениями можно тут (https://godbolt.org/z/7M9ns8K4T)

Ещё несколько примеров:  
- Вместо передачи по ссылке может использоваться передача по значению  
- Вместо `const <type>` может быть просто `<type>` т.к. при передаче по ссылке значение не поменяется.  
- Вместо `<type>&` может быть `const <type>&` т.к. в этом случае накладывается дополнительное ограничение.  
- Но нельзя вместо `const <type>` использовать `<type>&`.


Выводы:  
- использовать ссылки в `std::function` не имеет смысла. А вот реализацию нужно делать согласно здравому смыслу.
- использовать `const` можно и нужно в тех случаях, когда нужно гарантировать, что
объект не изменится. Но это не гарантирует способ передачи аргументов в
функцию.

## <a name="r9">Комментарий по результатам проверки домашнего задания</a>
Если не реализовано итерирование по списку - макс оценка 70.  
При использовании `shared_ptr` 100 баллов макс оценка 92.

Максимальные оценки могли получить те, кто использовал сырые указатели или `unique_ptr`.  
К сожалению, у большинства, кто использовал сырые указатели обнаружены утечки памяти.

Также заметил много однотипных ошибок:
___
Многие включали файлы следующим образом:
~~~C++
#include "SomeList.cpp"
~~~
Так делать неверно. Шаблоны реализуются в хидерах т.к. в момент инстанцирования он должен быть полностью определён.
___
Встречал очень много кода, который не компилируется или работает совсем не так, как вы предполагаете.  
Инстанцируются только те методы, которые вызываются. Т.е., если вы не используете метод - он не скомпилируется и вы не узнаете, что в нём ошибка.
Тестируйте код)
___

Не используете предварительную инициализацию либо используете её неверно.

Неправильно:
~~~C++
ClassName(const T& data){
    data_ = data;
}
~~~
Будет вызван конструктор по умолчанию, если он есть в классе, если нет - код не скомпилируется.  
После этого будет вызван оператор присваивания (перемещающий для rvalue, если не забыли `std::move`

Правильно:
~~~C++
ClassName(const T& data) : data_(data) {}
ClassName(T&& data) : data_(std::move(data) {}
~~~

Ещё важно понимать, что под стандартные типы (`int`, `double`) будет выделена память, но инициализация не произойдёт. Т.е. вы не знаете, что в них будет храниться - UB.

Такой вариант, тоже не скомпилируется для классов, у которых нет конструктора по умолчанию.
~~~C++
ClassName(const T& data = T()) : data_(data) {}
~~~
___

Не забывайте использовать аргументы по умолчанию
Эти 2 строки
~~~C++
Node(const T& data) : data_(data), next_(nullptr) {}
Node(const T& data, Node* next) : data_(data), next_(next) {}
~~~
можно было сделать как
~~~C++
Node(const T& data, Node* next = nullptr) : data_(data), next_(next) {}
~~~
___
Многие забывали инициализировать поля в списке инициализации и у них был мусор в указателе и размере (если его считали). Это тоже конструктор.  
___
Список инициализации нужно передавать по константной ссылке.  
Правильно как-то так:
~~~C++
Mylist(const std::initializer_list<T> &lst) : head(nullptr), size(0)
~~~
___
Семантика перемещения. У многих она работает неверно или вовсе не работает по нескольким причинам:  
- Забываете использовать `std::move` и `std::forward`. Их нужно использовать при каждой передаче аргумента.
- Сначала инициализируете класс конструктором по умолчанию, затем присваиваете ему значение.
~~~C++
node<T> *el = new node<T>();
el->value = std::move(val);
~~~
Передаёте далее в методы, которые принимают lvalue.

Как искать эти проблемы?   
Нужно написать класс, у которого определить все конструкторы и операторы присваивания. В этих методах вы можете выводить что-либо в консоль, понимая, какой именно метод вызывается. Так вам будет проще искать ошибки в реализации.
___

Не забывайте, в каких случаях какие методы не будут определяться.  
Некоторые определяли клнструктор перемещения, но забывали про конструктор копирования. В таком случае он не будет реализован компилятором.  
Можете использовать default, если думаете, что он вам подходит.
___

Утечки памяти.  
Если вы используете сырые указатели - нельзя использовать методы, реализуемые компилятором по умолчанию. Т.к. в таком случае копируется только указатель без данных. В деструкторе может произойти попытка очистить уже выделенные данные.  
Ту память, которую вы выделяете вы должны и очищать)

Как искать утечки? Можно использовать санитайзеры.  
Для данной ситуации можно сделать проще - в классе. который помогает понять, какой конструктор вызывается, добавить статическое поле для подсчёта объектов класса. В конструкторах делать инкремент, в деструкторах декремент.
___

Многие забывают проверять, пустой ли список в методе `pop_front`.  
Из-за этого происходит попытка освободить `nullptr`. Это нельзя перехватить в пользовательском коде.  
Можно бросать исключение или просто выходить из метода, но допускать такое нельзя.
___

Использование `thow exception`.  
В большинстве реализаций STL так нельзя сделать. используйте thow `std::runtime_error` вместо этого.
___

Нельзя возвращать ссылки на статические объекты.  
~~~C++
int& wrong(){
    int a = 10;
    return a;
}
~~~
___
Обход списка через оператор `[]`  
Такая реализация не подходит для обхода списка т.к. сложность O(n!) для обхода через итератор сложность будет o(n)
___
