# Разработка под Linux
## Оглавление
1. [MAN](#r1)
2. [Компиляция](#r2)
3. [make](#r3)
4. [Логирование](#r4)
5. [Переменные окружения](#r5)
6. [ВВОД-ВЫВОД](#r6)
7. [Процессы](#r7)
8. [Межпроцессное взаимодействие (IPC)](#r8)
    1. [Именованные и неименованные каналы](#r8_1)
    2. [Нити, они же потоки](#r8_2)
9. [Основні помилки за результатами перевірки домашніх завдань](#r9)


## <a name="r1">MAN</a>
Первое с чем стоит познакомится перед программированием под линукс это получение справки. Спецификацию к любому системному вызову или функции можно получить путем введения в терминал команды
~~~linux
man[имя команды]
~~~

## <a name="r2">Компиляция</a>
Для того чтобы скомпилировать программу под линукс вам необходимо воспользоваться линуксовым компилятором – **GCC** (это препроцессор, компилятор и линкер). К примеру, у вас есть классическая программка выводящая строку «Hello World» и находится она в файлe `hello.c`:  

~~~C
/* hello.c */
#include <stdio.h>

int main (void)
{
	printf ("Hello World\n");
}
~~~

Для того чтобы скомпилировать ее в исполняемый файл вам необходимо ввести команду:
	
    gcc hello.c

Этой командой вы вызываете `gcc` и говорите ему скомпилировать вам исполняемый файл. В данном случае у вас создается `a.out` файл который и является вашей программой. Если имя `a.out` вам не по душе вы можете задать имя программы передав `gcc` опцию `–o [имя программы]`.  

    gcc -o hello hello.c

Вот теперь у вас появляется исполняемый файл с именем `hello`, который можно использовать. Подробнее с опциями `gcc` вы можете познакомиться вызвав его справку:

    man gcc

Если вы доросли до того уровня что располагаете свою программу в разный файлах (`hello.c`, `print.c`), то для компиляции вам понадобится сначала скомпилировать объектные файлы:

	gcc –c hello.c
	gcc –c print.c

Опция `–с` как раз говорит `gcc` о том, что ему стоит скомпилировать. На выходе у вас появятся файлы `hello.o` и `print.o` соответственно.  
После успешной компиляции вам необходимо вызвать линкер и получить вашу программу:

	gcc -o hello print.o hello.o

## <a name="r3">make</a>
### Это утилита предназначена для сборки программ на основе `Makefile`'ов. Она:
1.	Спасает вас от рутинного ввода одних и тех же команд.
2.	Пересобирает только измененные файлы основываясь на последнем времени изменения файла.

### Содержимое Makefile это:
1) что нужно сделать (цель); 
2) что для этого нужно (зависимости); 
3) как это сделать (правила).  

В качестве **цели** выступает имя программы.   
**Зависимости** - это список файлов и целей, разделенных пробелом.  
**Правила** - это команды передаваемые оболочке.  

Рaссмотрим пример `Makefile` для нашей программы:
##### **Makefile for Hello World project**

~~~
hello: print.o hello.o
<--->gcc -o hello print.o hello.o

print.o: print.c
<--->gcc -c print.c

hello.o: hello.c
<--->gcc -c hello.c
~~~

Этот мейкфайл говорит утилите `make` следующее:  
Собери мне программу под названием `hello` для которой необходимым условием является наличие файлов `print.o`, `hello.o`, для сборки выполни команду `“gcc -o hello print.o hello.o”`.  Файл `print.o` зависит от `print.c` и получается в результате выполнения команды `“gcc -c print.c”` и так далее.  

После того как вы создали свой первый `Makefile` сохраните его в директории с исходными кодами программы и введите команду `“make”`. В результате вы получите все ту же программу.  

>**ВАЖНО!!!** Обратите внимание что все правила в мейкфайле отделены табуляцией, это обязательное условие о котором необходимо помнить во время создания своих мейкфайлов.

## <a name="r4">Логирование</a>
Для вывода сообщений в лог системы в линуксе используется `syslog`.   
- Открываем лог с необходимыми опциями: `openlog()`;  
- Записали в лог информативное сообщение: `syslog()`;  
- Закрыли лог: `closelog()`;  
- Спецификация к этим функциям может быть получена из их справки: `man syslog`.

## <a name="r5">Переменные окружения</a>
**Окружение** (environment) или **среда** - это набор пар *ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ*, доступный каждому пользовательскому процессу. Иными словами, **окружение** - это набор переменных окружения.   
Для того, чтобы посмотреть окружение, просто введите команду `env` без аргументов.   
Для работы с окружением нам доступны следующие вещи:
~~~C
	char * getenv (const char * name); 
~~~
Эта функция работает очень просто: если в качестве аргумента указано имя существующей переменной окружения, то функция возвращает указатель на строку, содержащую значение этой переменной; если переменная отсутствует, возвращается `NULL`.  
~~~C
	int setenv (const char * name, const char * value, int overwrite);
~~~
Функция `setenv()` устанавливает значение (второй аргумент, `value`) для переменной окружения (первый аргумент, `name`). Третий аргумент - это флаг перезаписи. При ненулевом флаге уже существующая переменная перезаписывается, при нулевом флаге переменная, если уже существует, - не перезаписывается.   
~~~C
	int unsetenv (const char * name);
~~~
Функция `unsetenv()` удаляет переменную с заданным именем из окружения.

## <a name="r6">ВВОД-ВЫВОД</a>
В линуксе все есть файл а по сему умение читать писать в файлы является необходимым пунктом.   Файловый ввод-вывод в линуксе представлен 4 основными функциями: `open()`, `close()`, `read()`, `write()`.
~~~C
	int open (const char * filename, int flags, mode_t mode);
~~~
Чтобы получить возможность прочитать что-то из файла или записать что-то в файл, его нужно открыть. Это делает системный вызов `open()`. Передаем имя файла и флаги с которыми его стоит открывать. Возвращает **файловый дескриптор** который можно использовать в функциях `read/write/close`.  
~~~C
	int close (int fd);
~~~
Системный вызов `close()` закрывает файл. Принимает в качестве параметра файловый дескриптор полученный в результате `close`.  
~~~C
	ssize_t read (int fd, void * buffer, size_t count);
~~~
Системный вызов `read()` позволяет читать данные из файла. Первый аргумент - это файловый дескриптор. Второй аргумент - это указатель на область памяти, куда будут помещаться данные. Третий аргумент - количество байт, которые функция `read()` будет пытаться прочитать из файла.
~~~C
	ssize_t write (int fd, const void * buffer, size_t count);
~~~
Записывает `count` байтов из буфера `buffer` в файл с дескриптором `fd`, возвращая количество записанных байтов или -1 в случае ошибки.  

Отличительной особенностью линукса является наличие функции:
~~~C
	size_t sendfile(int out_fd, int in_fd, off_t * offset , size_t count);
~~~
Эта функция производит запись из одного файлового `in_fd` дескриптора в другой `out_fd` эффективнее обычной комбинации вызовов `read/write`. Это достигается путем выполнения копирования на уровне пространства ядра. Подробнее можно посмотреть тут: `man sendfile`.

## <a name="r7">Процессы</a>
*Linux* - многозадачная операционная система. Одни процессы могут порождать другие процессы, образовывая древовидную структуру. *Порождающие* процессы называются родителями или родительскими процессами, а *порожденные* - потомками или дочерними процессами. На вершине этого "дерева" находится процесс `init`, который порождается автоматически ядром в процессе загрузки системы.   
Процесс может узнать свой идентификатор **(PID)**, а также родительский идентификатор **(PPID)** при помощи системных вызовов `getpid()` и `getppid()`. 
~~~C
	pid_t getpid (void);
	pid_t getppid (void);
~~~
Для клонирования процесса предназначен системный вызов `fork()`.  
~~~C
	pid_t fork (void);
~~~
После выполнения этого вызова вы получите два раздельно выполняемых процесса. Программе нужно позаботиться об идентификации своего "Я", то есть определении того, где родитель, а где потомок. Это делается очень просто: в родительский процесс `fork()` возвращает идентификатор *потомка*, а потомок получает 0. Следующий пример демонстрирует то, как это происходит. 
~~~C
/* fork01.c */
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main (void)
{
        pid_t pid = fork ();

        if (pid == 0) {
                printf ("child (pid=%d)\n", getpid());
        } else {
                printf ("parent (pid=%d, child's pid=%d)\n", getpid(), pid);
        }

        return 0;
}
~~~
Также в линуксе присутствует возможность замены образа программы:
~~~C
	int execve (const char * path, char const * argv[], char * const envp[]);
~~~
Системный вызов `execve()` заменяет текущий образ процесса программой из файла с именем `path`, набором аргументов `argv` и окружением `envp`. Здесь следует только учитывать, что `path` - это не просто имя программы, а путь к ней. Следующий пример демонстрирует запуск программы в отдельном процессе с использованием fork и execve.
~~~C
/* forkexec01.c */
#include <unistd.h>
#include <stdio.h>

extern char ** environ;

int main (void)
{
        char * echo_args[] = { "echo", "child", NULL };

        if (!fork ()) {
                execve ("/bin/echo", echo_args, environ);
                fprintf (stderr, "an error occured\n");
                return 1;
        }

        printf ("parent");
        return 0;
}
~~~
Программа клонируется с помощью `fork()`, если форк возвращает 0 значит мы сейчас выполняемся в дочернем процессе. После этого порожденный дочерний процесс производит замену образа программой `/bin/echo`.

## <a name="r8">Межпроцессное взаимодействие (IPC)</a>
### <a name="r8_1">Именованные и неименованные каналы</a>
Неименованный канал создается посредством вызова: 
~~~C
	int pipe(int pipefd[2]);
~~~
Функция возвращает вам два файловых дескриптора `pipefd[2]`.  
Вызывая `pipe` вы говорите системе следующую вещь: создай мне два файловых дескриптора. Все что будет записано в `pipefd[1]` можно будет считать из файлового дескриптора `pipefd[0]`. 

Именованный канал можно создать с использованием: 
~~~C
	int mkfifo(char const pathname, mode_t mode);
~~~  
Работает аналогично `pipe`, с отличием в том что:
- У вашего именованного канала есть представление в файловой системе которое вы передаете в параметре `char const pathname`.
- Время жизни `pipe` не превышает время жизни породившего его процесса. `fifo` — его еще называют именованным каналом нужно удалять при необходимости, т.к. цикл его существования не привязан к времени жизни процесса.

### <a name="r8_2">Нити, они же потоки</a>
Для работы с потоками в линуксе предоставлена библиотека `pthread`:
~~~C
	int pthread_create(pthread_t *thread,
                   	pthread_attr_t const *attr,
                  	void *(*start_routine) (void *),
                   	void *arg);
~~~
Функция создает поток `pthread_t *thread`, с аттрибутами определенными в `pthread_attr_t const *attr`.  

- `void *(*start_routine) (void *)` – это указатель на функцию которая будет выполняться в потоке.  
- `void *arg` – аргументы передаваемые функции которая будет выполняться в потоке.
- `int pthread_join(pthread_t thread, void **retval)` – функция присоединяется к потоку и ждет его завершения.  
- `void pthread_exit(void *retval)` – функция выходит из потока не завершая основную программу.   
- `retval`  - это значение которое возвращается функцией. Вызывается только внутри потока.  
- `int pthread_cancel(pthread_t thread)` – несанкционированное завершение потока из главной программы которая его породила. Вызывается только вне потока.

Пример создания двух потоков в которых будет выполняться функция `thread` выводящая на консоль номер потока который сейчас выполняется.

~~~C
#include <errno.h>
#include <pthread.h>

void *thread(void *arg)
{
    printf("Thread %i is running\n", *(int *)arg);
    pthread_exit(NULL);
}
int main(int argc, char * argv[])
{
    int id1 = 1, id2 = 2;
    pthread_t thread1, thread2;

    pthread_create(&thread1, NULL, thread, &id1);
    pthread_create(&thread2, NULL, thread, &id2);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    return errno;
}
~~~

## <a name="r9">Основні помилки за результатами перевірки домашніх завдань</a>
Task1:   
Не збирали код в статичну бібліотеку, не копіювали метадату файлу. Останне означає `st_mode` файлу, що можна було отримати з функції `stat` замість хардкоду 666 або переведення відповідальності за створення копії з однаковими правами на користувача.

Task2:  
Строку не було записано в файл. Інша помилка стосуєтсья закриття пайпу на читання в процесі на написання і навпаки. Якщо процес, що пише в пайп неочікувано впаде, а процес що читає не закриває пайп на запис до виклику функції `read()`, то програма зависне адже виклик `read()` є блокуючим, але програма не завершується бо дескриптор пайпу на запис ще валідний в поточному процесі.
