# Межпроцессное взаимодействие
## Оглавление
1. [File (Файл)](#r1)
2. [Pipe (Пайп)](#r2)
3. [Signal (Сигнал)](#r3)
4. [Shared Memory (Розділювана пам’ять)](#r4)
5. [Semaphore/Mutex (Семафор/М’ютекс)](#r5)
6. [Socket/Unix Socket/Windows Named Pipe](#r6)
7. [High Level Approach](#r7)
8. [Приклади](#r8)
    - [Приклад використання **pipe** (процес 1)](#r8_1)
    - [Приклад використання **pipe** (Процес 2, POSIX)](#r8_2)
    - [Приклад використання **pipe** в терміналі](#r8_3)
    - [Приклад використання Shared Memory (Windows)](#r8_4)
    - [Приклад RPC](#r8_5)
    



**Міжпроцесна взаємодія** – це обмін даними між потоками одного чи декількох процесів. Реалізується за допомогою механізмів, що їх надає ядро ОС. Може відбуватись як в межах одного комп’ютера, так і між різними комп’ютерами.

## <a name="r1">File (Файл)</a>
В більшості сучасних операційних систем  **файли** – це одновимірні масиви байт, що організовані у вигляді дерева за допомогою тек(folders). Щоб працювати із файлом, додаток має відкрити його, отримавши файловий дескриптор.

## <a name="r2">Pipe (Пайп)</a>
**Pipe** (Anonymous pipe) - «труба» для комунікації. 

**Анонімний пайп** – це односторонній канал зв’язку `FIFO`, який може бути використаний для односторонньої міжпроцесної взаємодії. Реалізація зазвичай є інтегрована в підсистему вводу-виводу операційної системи.  

**Типове використання:**
- Програма створює пайп або декілька пайпів, створює дочірній процес, який наслідує дескриптори пайпів. Далі пайп може використовуватись для комунікації (читання/запис) з дочірнім процесом;
- Програма створює декілька процесів послідовно, пов’язуючи їх потоки вводу-виводу між собою.

## <a name="r3">Signal (Сигнал)</a>
Сигнали в UNIX, Unix-подібних та інших POSIX-сумісних операційних системах – це ще один спосіб взаємодії між процесами.  

**Сигнал** – це асинхронне сповіщення процеса про будь-яку подію. Якщо процесу надісланий сигнал, операційна система перериває виконання процеса. Якщо процес зареєстрував власний обробник сигнала, операційна система викликає цього обробника, передаючи йому інформацію про сигнал. Якщо процес не встановив обробника, то виконується обробник за замовчуванням.

## <a name="r4">Shared Memory (Розділювана пам’ять)</a>
**Розділювана пам’ять** – це найшвидший спосіб обміну даними між процесами. В інших варіантах  міжпроцесної взаємодії обмін інформацією відбувається за участі ядра, що призводить до перемикання контекста між процесом і ядром, а отже до втрат продуктивності.  

Механізм розділюваної пам’яті дозволяє обмінюватись інформацією через спільну для процесів ділянку пам’яті без використання системних викликів ядра. Сегмент розділюваної пам’яті підвантажується у вільну частину адресного простору процеса. Таким чином, два різних процеси матимуть різні адреси тієї самої комірки підвантаженої розподілюваної пам’яті

## <a name="r5">Semaphore/Mutex (Семафор/М’ютекс)</a>
**Семафор** – це об’єкт, що обмежує кількість потоків, які можуть зайти на задану ділянку коду одночасно. Визначення зроблено *Едгером Дейкстрою*. Семафори використовують для синхронізації та захисту передачі даних через розділювану пам’ять, а також для синхронізації роботи процесів та потоків.

*Семафор* — це об’єкт, над яким можна виконати три операції:
-	Ініціалізація семафора (встановити початкове значення лічильника)
-	Захоплення семафора (чекати допоки лічильник не стане більше 0, після цього зменшити лічильник на одиницю)
-	Звільнення семафора (збільшити лічильник на одиницю)

**М’ютекс** — це семафор з лічильником 1. Використовується для ексклюзивного доступу до коду.

## <a name="r6">Socket/Unix Socket/Windows Named Pipe</a>
**Сокети** — назва програмного інтерфейса для забезпечення обміну даними між процесами. Слово «сокет» у програмному інтерфейсі  - це абстрактний об’єкт, що являє собою кінцеву точку з’єднання.

*Сокет домена Unix* (Unix domain socket, UDS) або *IPC-сокет* — кінцева точка обміну даними, схожа на Інтернет-сокети, проте вона не використовує мережевий протокол для взаємодії. Використовується в операційних системах, що підтримують стандарт POSIX, для міжпроцесної взаємодії. 

*Іменовані пайпи Windows* – це вид пайпів, що призначені для комунікації між пайповим сервером та одним або декількома клієнтами. У одного іменованого пайпа може бути декілька екземплярів (instance) з однаковим ім’ям але власним буфером та дескрипторами, що дозволяє різним клієнтам спілкуватися з сервером одночасно.

Спрощена схема клієнт-серверної взаємодії:
1)	Процес-сервер (або поток-сервер) створює деякий об’єкт, що слухає;
2)	Клієнти використовують API операційної системи для підключення до серверу;
3)	Операційна система сповіщає сервер про підключення клієнтів, і створює дексриптор з’єднання для кожного з клієнтів;
4)	Сервер пише/читає з використанням дескрипторів підключених клієнтів.


## <a name="r7">High Level Approach</a>
**Віддалений виклик процедур (RPC** Remote Procedure Call) — клас технологій, що дозволяють комп’ютерним програмам викликати функції чи процедури в іншому адресному просторі.
Ідея виклику віддалених процедур полягає в поширенні добре відомого та зрозумілого механізму передачі управління і даних всередині програми на передачу управління та даних через мережу. Найбільша ефективність використання RPC може бути досягнена в тих додатках, в яких існує інтерактивний зв’язок між віддаленими компонентами з невеликим часом відповіді та відносно малою кількістю даних, що передаються. 

![pic1](https://github.com/sotnikea/Internship_Apriorit/raw/main/part12/img/pic1.png)

## <a name="r8">Приклади</a>
### <a name="r8_1">Приклад використання **pipe** (процес 1)</a>

~~~C++
#include <iostream>
int main()
{
    std::cout<<"Hello, world!";
    return 0;
}
~~~
____
### <a name="r8_2">Приклад використання **pipe** (Процес 2, POSIX)</a>
~~~C++
int ExecuteCommandAndReadOutput(const char *pCommand, 
                                std::string * pTextResult)
{
    pTextResult->clear();
    char buffer[512];
    FILE* pipe = popen(pCommand, "r"); // у Windows існує _popen
    if (!pipe)
        throw std::runtime_error("Can’t execute command");
    while (!feof(pipe))
    {
        if (fgets(buffer, sizeof(buffer), pipe))
                pTextResult->append(buffer);
    }
    return pclose(pipe);
}
~~~

### <a name="r8_3">Приклад використання **pipe** в терміналі</a>
~~~
Windows:	
>dir | find "Downloads"

POSIX:	
>ls | grep 'something'
~~~

### <a name="r8_4">Приклад використання Shared Memory (Windows)</a>
~~~
#pragma comment(linker, "/SECTION:.shared,RWS")
#pragma data_seg(".shared")
int g_iShared = 0;  // розділювана змінна
#pragma data_seg()
~~~

### <a name="r8_5">Приклад RPC</a>
~~~C++
// 1. Маємо сервер і деякий алгоритм
int SomeFunction(int arg1,
                const std::string & arg2, 
                double arg3)
{       
         // …. Супер алгоритм
}

// 2. Клієнт хоче його використовувати таким чином 
int x = SomeFunction(arg1,  arg2, arg3);
std::cout<<x;

// Client Stub Sample
int SomeFunction(Connection & connection,
                int arg1,
                const std::string & arg2, 
                double arg3){       // зберігаємо
        SomeArchive inputArchive;
        inputArchive.Pack("function-name", "SomeFunction");
        inputArchive.Pack("arg1", arg1);
        inputArchive.Pack("arg2", arg2);
        inputArchive.Pack("arg3", arg3);
        // отримуємо буфер
        std::vector<char> buffer;
        inputArchive.Serialize(&buffer);
        // відправляємо буфер
        std::vector<char> outputBuffer;
        connection.Send(buffer, &outputBuffer);
        // парсимо результат
        SomeArchive outputArchive(outputBuffer);
        return  outputArchive.QueryInt("result");
}

// Server Code Sample
void ServerCodeSample(Connection & connection)
{       
        std::vector<int> buffer;
        while(connection.ReadPacket(&buffer))
        {
                SomeArchive archive(buffer);
                SomeArchive outputArchive;
                // аналізуємо пакет
                std::string functionName = archive.QueryString("function-name");
                if (functionName == "SomeFunction")
                {
                        ServerStub_SomeFunction(archive, &outputArchive);
                }
                // відправляємо результат
                std::vector<char> outputBuffer;
                outputArchive.Serialize(&outputBuffer);
                connection.SendAnswer(outputBuffer);
        }
}

void ServerStub_SomeFunction(SomeArchive & archive, 
                            SomeArchive & outputArchive)
{
        // читаємо параметри
        int arg1 = archive.QueryInit("arg1");
        std::string arg2 = archive.QueryString("arg2");
        double arg3 = archive.QueryDouble("arg3");

        // викликаємо оригінальну функцію
        int result = SomeFunction(arg1, arg2, arg3);

        // зберігаємо результат
        outputArchive.Pack("result", result);
}
~~~

